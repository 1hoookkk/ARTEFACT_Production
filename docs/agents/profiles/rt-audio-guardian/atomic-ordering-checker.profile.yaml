# Atomic Ordering Checker Profile v1.0
# Specialized RT-Audio Guardian variant for memory ordering validation

name: atomic-ordering-checker
parent: rt-audio-guardian
version: "1.0.0"
specialization: "Memory ordering and atomic operation validation"

description: >
  Specialized variant for validating atomic memory ordering in RT-audio contexts.
  Ensures correct memory_order specifications, prevents data races, and validates
  lock-free programming patterns in SpectralCanvas Pro's multi-threaded architecture.

# Enhanced Triggers
additional_triggers:
  diff_contains:
    - "std::atomic"
    - "memory_order"
    - "atomic_"
    - ".load("
    - ".store("
    - ".exchange("
    - "compare_exchange"

# Memory Ordering Rules
specialized_rules:
  memory_ordering_patterns:
    relaxed_for_counters:
      description: "Performance counters can use memory_order_relaxed"
      safe_contexts:
        - "statistics counters"
        - "non-critical state flags"
        - "debugging information"
      pattern: "counter.*load.*memory_order_relaxed"
      
    acquire_release_for_synchronization:
      description: "Synchronization points need acquire/release ordering"
      required_contexts:
        - "Queue head/tail pointers"
        - "Component lifecycle flags"
        - "Parameter update flags"
      patterns:
        - "ready_flag.*store.*memory_order_release"
        - "ready_flag.*load.*memory_order_acquire"
        
    seq_cst_for_critical:
      description: "Critical audio state may need sequential consistency"
      contexts:
        - "Audio processing enabled/disabled"
        - "Plugin state changes"
        - "Error condition flags"
      default_if_unsure: true

  atomic_usage_patterns:
    parameter_atomics:
      description: "Audio parameters should use appropriate atomic types"
      preferred_types:
        - "std::atomic<float>"
        - "std::atomic<bool>"
        - "std::atomic<int>"
      avoid_types:
        - "std::atomic<std::string>"  # Too expensive
        - "std::atomic<large_struct>"  # May not be lock-free
        
    flag_patterns:
      description: "Boolean flags for RT-safety"
      examples:
        - "std::atomic<bool> processing_enabled_{false};"
        - "std::atomic<bool> component_ready_{false};"
      required_ordering: "memory_order_acq_rel for state changes"

# Data Race Detection
race_detection:
  common_patterns:
    shared_state_without_atomic:
      violations:
        - "Non-atomic variable accessed from multiple threads"
        - "Plain bool used for thread communication"
        - "Raw pointer shared between threads"
      severity: critical
      
    mixed_atomic_non_atomic:
      violations:
        - "Same variable accessed atomically and non-atomically" 
        - "Atomic wrapper around non-atomic operations"
      severity: high
      
    spurious_ordering:
      violations:
        - "memory_order_seq_cst used unnecessarily"
        - "memory_order_acq_rel for simple loads"
        - "Inconsistent ordering in producer/consumer pair"
      severity: medium

# Platform-Specific Considerations
platform_atomics:
  x86_64:
    natural_atomics: ["char", "short", "int", "long", "pointer"]
    acquire_release_free: "x86 has strong memory model"
    
  arm64:
    weak_memory_model: "Requires explicit memory barriers"
    ldxr_stxr_loops: "Compare-exchange may use load-exclusive/store-exclusive"
    
  general:
    lock_free_guarantee: "Check std::atomic<T>::is_lock_free()"
    alignment_requirements: "Atomic types need proper alignment"

# Analysis Patterns
analysis_patterns:
  ordering_consistency:
    producer_consumer_pairs:
      - "Queue head store should use memory_order_release"
      - "Queue tail load should use memory_order_acquire" 
      - "Data writes before head store, data reads after tail load"
      
  performance_analysis:
    ordering_overhead:
      - "memory_order_relaxed: Minimal overhead"
      - "memory_order_acquire/release: Memory barriers"
      - "memory_order_seq_cst: Full synchronization"
    cache_behavior:
      - "Atomic operations may cause cache line bouncing"
      - "False sharing between atomic variables"

# Enhanced KPIs
additional_kpis:
  memory_ordering_correctness: "> 0.95"    # Correct ordering patterns
  data_race_elimination: "= 1.0"           # Zero data races
  lock_free_guarantee: "> 0.9"             # Percentage of lock-free atomics
  performance_impact_score: "< 0.2"        # Relative to baseline

# Test Fixtures
test_fixtures:
  - name: "inconsistent_ordering"
    code: |
      // Producer
      data = value;
      flag.store(true, std::memory_order_relaxed);  // VIOLATION
      
      // Consumer  
      if (flag.load(std::memory_order_acquire)) {   // VIOLATION
          use(data);  // Potential data race
      }
    expected_violations: ["Inconsistent memory ordering"]
    
  - name: "correct_acquire_release"
    code: |
      // Producer
      data = value;
      flag.store(true, std::memory_order_release);  // OK
      
      // Consumer
      if (flag.load(std::memory_order_acquire)) {   // OK
          use(data);  // Safe
      }
    expected_violations: []

# Output Extensions
output_extensions:
  memory_ordering_analysis:
    ordering_patterns:
      - pattern: string
        frequency: integer
        correctness_score: number
    race_conditions:
      - variable: string
        threads_involved: array[string] 
        risk_level: enum[critical, high, medium, low]
    performance_impact:
      estimated_overhead_percent: number
      cache_behavior_prediction: string