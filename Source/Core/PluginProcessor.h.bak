// Source/Core/PluginProcessor.h
#pragma once

#include <JuceHeader.h>
#include "Core/CrashToggles.h"
#include "Core/Config.h"
#include "Core/EMUFilter.h"
#include "Core/PaintQueue.h"
#include "Core/SpectralPath.h"
#include "ParamIDs.h"

// Command system includes (minimal command queue for 7-file core)
#include <array>
#include <atomic>

//==============================================================================
// Forward declarations to reduce dependencies
#include "GUI/HudOverlay.h"
class SpectralSynthEngine;

//==============================================================================
// Minimal Command System for 7-file core
enum class ForgeCommandID : int;
enum class SampleMaskingCommandID : int;
enum class PaintCommandID : int;
enum class RecordingCommandID : int;

struct Command
{
    // Minimal command structure for essential functionality
    ForgeCommandID forgeID = static_cast<ForgeCommandID>(0);
    float floatParam = 0.0f;
    int intParam = 0;
    bool boolParam = false;
    float x = 0.0f, y = 0.0f, pressure = 0.0f;
    juce::Colour color = juce::Colours::white;
    double doubleParam = 0.0;
    char stringParam[256] = {0};
    
    // Constructors for common command types
    Command() = default;
    Command(ForgeCommandID id, int param) : forgeID(id), intParam(param) {}
    Command(ForgeCommandID id, int param, float value) : forgeID(id), intParam(param), floatParam(value) {}
    
    // Command type checking
    bool isForgeCommand() const { return true; } // Simplified for 7-file core
    bool isSampleMaskingCommand() const { return false; }
    bool isPaintCommand() const { return false; }
    bool isRecordingCommand() const { return false; }
    
    ForgeCommandID getForgeCommandID() const { return forgeID; }
    const char* getStringParam() const { return stringParam; }
};

//==============================================================================
// Minimal RT-safe lock-free queue for commands
template<typename T, size_t Size = 1024>
class LockFreeQueue
{
public:
    bool push(const T& item)
    {
        const auto current_tail = tail.load();
        const auto next_tail = increment(current_tail);
        if(next_tail != head.load())
        {
            ring[current_tail] = item;
            tail.store(next_tail);
            return true;
        }
        return false; // queue is full
    }
    
    bool pop(T& item)
    {
        const auto current_head = head.load();
        if(current_head == tail.load())
            return false; // queue is empty
        
        item = ring[current_head];
        head.store(increment(current_head));
        return true;
    }
    
    int getNumReady() const
    {
        auto h = head.load();
        auto t = tail.load();
        return (t >= h) ? (t - h) : (Size - h + t);
    }
    
    template<typename Func>
    void processWithTimeLimit(Func&& func, double maxTimeMs)
    {
        auto startTime = juce::Time::getMillisecondCounterHiRes();
        T item;
        while (pop(item))
        {
            func(item);
            if (juce::Time::getMillisecondCounterHiRes() - startTime > maxTimeMs)
                break;
        }
    }
    
private:
    std::array<T, Size> ring;
    std::atomic<size_t> head{0};
    std::atomic<size_t> tail{0};
    
    size_t increment(size_t idx) const { return (idx + 1) % Size; }
};

//==============================================================================
// Processing modes for the 7-file core
enum class ProcessingMode
{
    Canvas = 0,
    Forge = 1,
    Hybrid = 2
};

//==============================================================================
// RT-safe telemetry for HUD display
struct RTTelemetry
{
    std::atomic<int> evPushed{0};
    std::atomic<int> evPopped{0};
    std::atomic<int> maxQDepth{0};
    std::atomic<float> lastBlockRMS{0.0f};
};

//==============================================================================
// Minimal Synth Band for Heartbeat Slice engine
struct SynthBand
{
    float frequencyHz = 440.0f;
    float amplitude = 0.0f;
    float pan = 0.0f;
    juce::dsp::Complex<float> phasor{1.0f, 0.0f};
};

//==============================================================================
// Minimal source image container
struct SourceImage
{
    juce::Image image;
};

//==============================================================================
// Main processor class with minimal dependencies
class ARTEFACTAudioProcessor : public juce::AudioProcessor,
                               public juce::AudioProcessorValueTreeState::Listener
{
public:
    //==============================================================================
    ARTEFACTAudioProcessor();
    ~ARTEFACTAudioProcessor() override;

    //==============================================================================
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

#ifndef JucePlugin_PreferredChannelConfigurations
    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;
#endif

    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    //==============================================================================
    const juce::String getName() const override { return JucePlugin_Name; }

    bool acceptsMidi() const override
    {
#if JucePlugin_WantsMidiInput
        return true;
#else
        return false;
#endif
    }

    bool producesMidi() const override
    {
#if JucePlugin_ProducesMidiOutput
        return true;
#else
        return false;
#endif
    }

    bool isMidiEffect() const override
    {
#if JucePlugin_IsMidiEffect
        return true;
#else
        return false;
#endif
    }

    double getTailLengthSeconds() const override { return 0.0; }

    //==============================================================================
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int index) override {}
    const juce::String getProgramName(int index) override { return {}; }
    void changeProgramName(int index, const juce::String& newName) override {}

    //==============================================================================
    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    //==============================================================================
    // Parameter listener
    void parameterChanged(const juce::String& parameterID, float newValue) override;

    //==============================================================================
    // Command queue management
    bool pushCommandToQueue(const Command& newCommand);
    void processCommands();
    void processCommand(const Command& cmd);
    void processForgeCommand(const Command& cmd);
    void processSampleMaskingCommand(const Command& cmd);
    void processPaintCommand(const Command& cmd);
    void processRecordingCommand(const Command& cmd);

    //==============================================================================
    // Paint brush system (minimal for 7-file core)
    void setActivePaintBrush(int slotIndex);
    void triggerPaintBrush(float canvasY, float pressure);
    void stopPaintBrush();

    //==============================================================================
    // Audio processing control
    void pauseAudioProcessing();
    void resumeAudioProcessing();

    //==============================================================================
    // Heartbeat Slice - Paint-to-Audio DSP Core
    void updateAndRender(juce::AudioBuffer<float>& buffer);

    //==============================================================================
    // Public member access for editor
    juce::AudioProcessorValueTreeState apvts;
    
    // HUD metrics queue for real-time display
    LockFreeQueue<SpectralCanvas::HudMetrics, 256> hudMetricsQueue;

    //==============================================================================
    // Paint queue access for editor
    PaintGestureQueue& getPaintQueue() noexcept;

    // Parameter snapshot for audio thread
    struct ParameterSnapshot { float masterGain=0.5f, freqMax=20000.f; bool paintActive=true; };
    ParameterSnapshot snapshot() const noexcept;

private:
    //==============================================================================
    // Parameter layout creation
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    //==============================================================================
    // Core engine state
    ProcessingMode currentMode = ProcessingMode::Canvas;
    double currentSampleRate = 44100.0;
    double lastKnownBPM = 120.0;
    
    // Engine preparation guards
    std::atomic<bool> enginePrepared{false};
    std::atomic<bool> parametersListenersRegistered{false};
    
    // Audio processing control
    bool audioProcessingPaused = false;
    
    // Paint brush system
    int activePaintBrushSlot = 0;

    //==============================================================================
    // Command queue system
    LockFreeQueue<Command, 1024> commandQueue;
    
    //==============================================================================
    // Atomic parameter cache for RT-safe parameter handling
    std::atomic<float> masterGainAtomic{0.7f};
    std::atomic<bool> paintActiveAtomic{false};
    std::atomic<int> processingModeAtomic{1}; // Canvas mode
    
    std::atomic<bool> masterGainDirty{false};
    std::atomic<bool> paintActiveDirty{false};
    std::atomic<bool> processingModeDirty{false};

    //==============================================================================
    // RT-safe audio buffers (pre-allocated in prepareToPlay)
    juce::AudioBuffer<float> maskingBuffer;
    juce::AudioBuffer<float> paintBuffer;

    //==============================================================================
    // RT-safe telemetry for HUD display
    RTTelemetry rtTelemetry;
    std::atomic<int> metricsSerial{0};

    //==============================================================================
    // Heartbeat Slice - Paint-to-Audio Engine Core
    std::vector<SynthBand> synthBands;
    SourceImage sourceImage;
    double currentColumn = 0.0;

    //==============================================================================
    // Crash bisection debugging
    std::atomic<unsigned> debugStageMask{0xFFFFFFFFu};

    //==============================================================================
    // Paint queue and spectral engine integration
    PaintGestureQueue paintQueue;  // owns the SPSC
    std::unique_ptr<SpectralSynthEngine> engine;
    std::unique_ptr<SpectralCanvas::SpectralPath> spectralPath;
    EMUFilter filter_;  // EMU filter for audio processing
    int editorWidthFallback  = 800; // until editor posts real size
    int editorHeightFallback = 600;

    //==============================================================================
    // ARCHIVED ENGINE STUBS - commented out for minimal build
    // These will be restored once the minimal core is stable
    
    /*
    // Paint engine for canvas mode
    PaintEngine paintEngine;
    
    // Spectral synthesis engine
    SpectralSynthEngine spectralSynthEngine;
    
    // Sample masking engine
    SampleMaskingEngine sampleMaskingEngine;
    
    // Audio recorder for session capture
    AudioRecorder audioRecorder;
    
    // Forge processor for sample playback
    ForgeProcessor forgeProcessor;
    */

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ARTEFACTAudioProcessor)
};